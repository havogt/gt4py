# GT4Py - GridTools Framework
#
# Copyright (c) 2014-2023, ETH Zurich
# All rights reserved.
#
# This file is part of the GT4Py project and the GridTools framework.
# GT4Py is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or any later
# version. See the LICENSE.txt file at the top-level directory of this
# distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import annotations

import dataclasses
import inspect
import itertools
import operator
from typing import Any, Callable, TypeGuard, overload

import numpy as np

from gt4py._core import definitions as core_defs
from gt4py.next import common
from gt4py.next.embedded import (
    common as embedded_common,
    exceptions as embedded_exceptions,
    nd_array_field as nd,
)
from gt4py.next.ffront import fbuiltins

# TODO extract binding and adding arguments functionality: check boltons


@dataclasses.dataclass(frozen=True)
class _Unbound:
    pos: int


@dataclasses.dataclass(frozen=True)
class _Bound:
    value: Any


class _Unused:
    ...


@dataclasses.dataclass(frozen=True)
class _FunWrapper:
    fun: Callable
    _bound: dict[int, Any]
    _mask: list[bool]

    @property
    def arity(self) -> int:
        return len(self._mask)

    @property
    def _fun_arity(self) -> int:
        return self._mask.count(True) + len(self._bound)

    @classmethod
    def from_function(cls, fun: Callable) -> _FunWrapper:
        params = inspect.signature(fun).parameters.values()
        if not all(
            p.kind in [inspect.Parameter.POSITIONAL_OR_KEYWORD, inspect.Parameter.POSITIONAL_ONLY]
            for p in params
        ):
            raise ValueError(
                "Expected a function that accept only a fixed number of positional arguments."
            )
        return _FunWrapper(fun, {}, [True] * len(params))

    def __call__(self, *args: Any) -> Any:  # TODO paramspec
        unbound_pos = iter([i for i, m in enumerate(self._mask) if m])
        fun_args = [self._bound.get(i) or args[next(unbound_pos)] for i in range(self._fun_arity)]
        return self.fun(*fun_args)

    def bind(self, bind_args: dict[int, Any]) -> _FunWrapper:
        unbound_pos = [i for i, m in enumerate(self._mask) if m]
        mapping = [i for i in range(self._fun_arity) if self._bound.get(i) is None]
        m = {k: v for k, v in zip(unbound_pos, mapping)}
        new_bound = self._bound.copy()
        new_mask = self._mask.copy()
        for i, v in bind_args.items():
            if self._mask[i]:
                new_bound[m[i]] = v
                new_mask.pop(i)
        return _FunWrapper(self.fun, new_bound, new_mask)

    def add_unused_parameters(self, *positions: int) -> _FunWrapper:
        if max(positions) > self.arity + len(positions):
            raise ValueError(f"Cannot fill with parameters.")

        for i in positions:
            self._mask.insert(i, False)
        return _FunWrapper(self.fun, self._bound, self._mask)


@dataclasses.dataclass(frozen=True)
class FunctionField(common.FieldBuiltinFuncRegistry, common.Field[common.DimsT, core_defs.ScalarT]):
    """A `FunctionField` represents a field of values generated by a callable function over a specified domain.

    The function supplied to the `func` parameter will be used to create the ndarray when accessing
    the `ndarray` property. The result of calling `ndarray` will be the same as using
    `np.fromfunction` with the provided function.

    Args:
        func (Callable): The callable function that generates field values.
        domain (common.Domain, optional): The domain over which the function is defined.
            Defaults to an empty domain.

    Examples:
        Create a FunctionField and compute its ndarray:

        >>> import numpy as np
        >>> from gt4py.next import common
        >>> from gt4py.next.embedded.function_field import FunctionField
        >>> I = common.Dimension("I")
        >>> domain = common.Domain((I, common.UnitRange(0, 5)))
        >>> func = lambda i: i ** 2
        >>> field = FunctionField(func, domain)
        >>> ndarray = field.ndarray
        >>> expected_ndarray = np.fromfunction(func, (5,))
        >>> np.array_equal(ndarray, expected_ndarray)
        True
    """

    func: Callable
    domain: common.Domain = common.Domain()

    def __post_init__(self):
        if not callable(self.func):
            raise embedded_exceptions.FunctionFieldError(
                self.__class__.__name__,
                f"Invalid first argument type: Expected a function but got {self.func}",
            )

        if __debug__:
            # try:
            self._trigger_func()
            # except Exception:
            #     params = _get_params(self.func)
            #     raise embedded_exceptions.FunctionFieldError(
            #         self.__class__.__name__,
            #         f"Invariant violation: len(self.domain) ({len(self.domain)}) does not match the number of parameters of the provided function ({params})",
            #     )

    @property
    def __gt_dims__(self) -> tuple[common.Dimension, ...]:
        return self.domain.dims

    @property
    def __gt_origin__(self) -> tuple[int, ...]:
        return tuple(-r.start for _, r in self.domain)

    def _trigger_func(self):
        target_shape = tuple(1 for _ in range(len(self.domain)))
        print(target_shape)
        return np.fromfunction(self.func, target_shape)

    @property
    def dtype(self) -> core_defs.DType[core_defs.ScalarT]:
        return core_defs.dtype(self.ndarray.dtype.type)

    def restrict(self, index: common.AnyIndexSpec) -> FunctionField:
        new_domain = embedded_common.sub_domain(self.domain, index)
        print(new_domain)
        index_sequence = common.as_any_index_sequence(index)

        def new_func(*args):
            if common.is_absolute_index_sequence(index_sequence):
                index_dict = {d: i for d, i in index_sequence}
                bound_args = []
                i = 0
                for dim, rng in self.domain:
                    if dim in index_dict and common.is_int_index(index_dict[dim]):
                        bound_args.append(index_dict[dim])
                    else:
                        bound_args.append(args[i])
                        i = i + 1
            else:  # relative
                ...
            return self.func(*bound_args)

        if len(new_domain) == 0:
            return self.__class__(
                new_func, new_domain
            ).ndarray  # TODO need to partially bind args in case we reduce dimension
        return self.__class__(new_func, new_domain)

    __getitem__ = restrict

    @property
    def ndarray(self) -> core_defs.NDArrayObject:
        # handle case where we have a constant FunctionField where field.ndarray is a scalar
        if (
            isinstance(self._trigger_func(), (int, float)) and not self.domain.is_finite()
        ):  # TODO cover all relevant types if this code path still makes sense
            return np.full(tuple(1 for _ in self.domain.shape), self.func())

        if not self.domain.is_finite():
            raise embedded_exceptions.InfiniteRangeNdarrayError(
                self.__class__.__name__, self.domain
            )
        return np.fromfunction(self.func, self.domain.shape)

    def _handle_function_field_op(self, other: FunctionField, op: Callable) -> FunctionField:
        domain_intersection = self.domain & other.domain
        broadcasted_self = _broadcast(self, domain_intersection.dims)
        broadcasted_other = _broadcast(other, domain_intersection.dims)
        return self.__class__(
            _compose(op, broadcasted_self, broadcasted_other),
            domain_intersection,
        )

    def _handle_scalar_op(self, other: FunctionField, op: Callable) -> FunctionField:
        def new_func(*args):
            return op(self.func(*args), other)

        return self.__class__(
            new_func, self.domain
        )  # skip invariant as we cannot deduce number of args

    @overload
    def _binary_operation(self, op: Callable, other: core_defs.ScalarT) -> common.Field:
        ...

    @overload
    def _binary_operation(self, op: Callable, other: common.Field) -> common.Field:
        ...

    def _binary_operation(self, op, other):
        if isinstance(other, self.__class__):
            return self._handle_function_field_op(other, op)
        elif isinstance(other, (int, float)):
            return self._handle_scalar_op(other, op)
        else:
            return op(other, self)

    def _unary_op(self, op: Callable) -> FunctionField:
        return self.__class__(_compose(op, self), self.domain)

    def __add__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.add, other)

    def __sub__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.sub, other)

    def __mul__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.mul, other)

    def __truediv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.truediv, other)

    def __floordiv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.floordiv, other)

    def __mod__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.mod, other)

    __rmod__ = __mod__

    def __pow__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.pow, other)

    def __lt__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.lt, other)

    def __le__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.le, other)

    def __gt__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.gt, other)

    def __ge__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.ge, other)

    def __and__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.and_, other)

    __rand__ = __and__

    def __or__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.or_, other)

    __ror__ = __or__

    def __xor__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.xor, other)

    __rxor__ = __xor__

    def __radd__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y + x, other)

    def __rfloordiv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y // x, other)

    def __rmul__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y * x, other)

    def __rsub__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y - x, other)

    def __rtruediv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y / x, other)

    def __pos__(self) -> common.Field:
        return self._unary_op(operator.pos)

    def __neg__(self) -> common.Field:
        return self._unary_op(operator.neg)

    def __abs__(self) -> common.Field:
        return self._unary_op(abs)

    def __invert__(self) -> common.Field:
        if self.dtype == core_defs.BoolDType():
            return self._unary_op(operator.invert)
        raise NotImplementedError("`__invert__` not implemented for non-`bool` fields.")

    def __call__(self, *args, **kwargs) -> common.Field:
        return self.func(*args, **kwargs)

    def remap(self, *args, **kwargs) -> common.Field:
        raise NotImplementedError("Method remap not implemented")


def _compose(operation: Callable, *fields: FunctionField) -> Callable:
    return lambda *args: operation(*[f.func(*args) for f in fields])


def _broadcast(field: FunctionField, dims: tuple[common.Dimension, ...]) -> FunctionField:
    def broadcasted_func(*args: int | core_defs.NDArrayObject):
        selected_args = [args[i] for i, dim in enumerate(dims) if dim in field.domain.dims]
        return field.func(*selected_args)

    named_ranges = embedded_common.broadcast_domain(field, dims)
    return FunctionField(broadcasted_func, common.Domain(*named_ranges))


def _is_nd_array(other: Any) -> TypeGuard[nd._BaseNdArrayField]:
    return isinstance(other, nd._BaseNdArrayField)


def constant_field(
    value: core_defs.ScalarT, domain: common.Domain = common.Domain()
) -> common.Field:
    return FunctionField(lambda *args: value, domain)


def _compose_function_field_with_builtin(builtin_name: str) -> Callable:
    def _composed_function_field(field: FunctionField) -> FunctionField:
        if builtin_name not in _UNARY_BUILTINS:
            raise ValueError(f"Unsupported built-in function: {builtin_name}")

        if builtin_name in ["abs", "power", "gamma"]:
            return field

        builtin_func = getattr(np, builtin_name)

        def new_func(*args):
            return builtin_func(field.func(*args))

        new_field: FunctionField = FunctionField(new_func, field.domain)
        return new_field

    return _composed_function_field


FunctionField.register_builtin_func(fbuiltins.broadcast, _broadcast)

_UNARY_BUILTINS = (
    fbuiltins.UNARY_MATH_FP_BUILTIN_NAMES
    + fbuiltins.UNARY_MATH_FP_PREDICATE_BUILTIN_NAMES
    + fbuiltins.UNARY_MATH_NUMBER_BUILTIN_NAMES
)

for builtin_name in _UNARY_BUILTINS:
    if builtin_name in ["abs", "gamma"]:
        continue
    FunctionField.register_builtin_func(
        getattr(fbuiltins, builtin_name), _compose_function_field_with_builtin(builtin_name)
    )

FunctionField.register_builtin_func(fbuiltins.abs, FunctionField.__abs__)  # type: ignore[attr-defined]


def _get_params(func: Callable) -> str:
    """Pretty print callable parameters."""
    signature = inspect.signature(func)
    parameters = signature.parameters
    param_strings = [f"{name}: {param}" for name, param in parameters.items()]
    formatted_params = ", ".join(param_strings)
    return formatted_params
